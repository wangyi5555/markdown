# 对象的创建 

## 单例模式 

在类内部添加对象属性instance，并把构造器私有化，提供getInstance方法调用该对象

适用于当目标类在运行过程中只需要一个对象的时候

- 懒汉式：在调用时才生成单例对象
- 饿汉式：在定义时就初始化，方法要用synchronized（双重检查null）
- 静态内部类：定义静态内部类，并把对象属性和初始化放在静态内部类中
- 枚举：定义枚举类，并只生成一个枚举对象

 

- 懒汉式：线程安全，调用效率高，不能延时加载
- 饿汉式：线程安全，调用效率不高，能延时加载
- 静态内部类：线程安全，调用效率高，可以延时加载
- 枚举类：线程安全，调用效率高，不能延时加载，同时可以防止反射和反序列化漏洞



## 工厂模式

定义一个类专门用于某些对象的创建

简单工厂模式：定义一个类，并在类中的一个方法声明所有相关对象的创建

工厂方法模式：定义一个工厂接口，其他类引用该接口产生各自类的工厂

抽象工厂模式：类似于工厂方法，但是在每个工厂都创建多个不同的相关对象，类似于分组

用于增加产品族，对于增加单个产品并不方便，



## 建造者模式

用于创建组成较为复杂的类

在抽象工厂模式的基础上新建一个组装类，在组装类的方法中创建需要的组件并把最终对象设置好



## 原型模式

通过new来产生一个新对象需要较为复杂的数据和准备

类继承Cloneable接口并实现clone()方法

注意浅拷贝和深拷贝的区别

浅克隆：super.clone()

深克隆：每个属性也需要调用clone方法



# 对象和类的组织 

## 适配器模式

两个不同的类之间沟通调用的桥梁，使用适配器模式可以让一个类适配不同的类方法

定义一个适配器接口并让一个实体类继承，在实体类中实现具体需要完成的工作



## 代理模式

通过代理来控制对象的访问

### 静态代理：使用自定义的类来代理访问

生成代理接口，然后生成真实角色类和代理角色类并调用该接口，把真实角色对象放入代理角色属性中并在代理角色内完成对真实角色的调用

### 动态代理

Proxy：动态生成代理类

InvocationHandler:处理器接口

生成代理接口，生成处理器类并实现InvocationHandler接口，在invoke方法中完成对方法的处理（所有的代理接口的方法在调用时都会进入到该方法中），在使用时生成代理对象并调用Proxy.newProxyInstance

（类加载器，功能接口类class对象，代理器对象）方法来获取代理对象



## 桥接模式

二维分类的类的添加

把两个变化的维度分开，为两个维度分别定义类并把其中一个作为另一个的属性，然后具体的属性继承这些类，这样在新添加某些类时可以只处理一个

例如产品类和品牌类



## 组合模式

使用树形结构来让简化客户端的处理。递归

例如扫描并列出文件夹



## 外观模式

让客户端类尽可能少地与底层打交道，建立一个类来统一实现对外的功能



## 装饰模式

用于代替继承，无需通过继承就可以扩展对象的新功能

创建装饰对象，并把真实对象作为装饰对象的属性，这样在创建基础对象时可以通过组合创建更多的复合对象，产生更多的复合功能

IO流



## 享元模式

在很多个相同或相似的对象存在时来节省内存

内部状态：可以共享，不会随环境变化

外部状态：不可共享，会随环境变化

 

定义完整基础接口

定义外部状态类

定义内部状态类继承继承接口，并在类中完成需要用到外部状态的方法

建立享元工厂类，以键值对方式存储属性，设置方法来访问属性

 

围棋：颜色和位置的区别

定义棋子的抽象接口

定义位置类

定义颜色类继承棋子接口

定义工厂类存放颜色-颜色类对，在使用时只需要在里面取出来即可

调用颜色类对象的方法处理位置

 

用时间换取空间

# 对象之间的相互交互 

## 责任链模式

将能够处理同一类请求的对象连成一条链，方便流程内容的变动，利于扩展

 

定义抽象类处理者，声明相关的属性和方法：

责任链的后继对象以及设置后继对象的方法

定义信息类

继承抽象处理者并分别类定义每个处理者类

 

接力赛跑，请假申请



## 迭代器模式

提供一种可以遍历整合对象的方式

定义迭代器的接口

定义容器类

定义迭代器类使用迭代器的接口



## 中介者模式

方便管理协调，用于复杂的对象

定义中介者接口

定义工作者接口

定义中介者类

定义各个工作者类，持有中介者对象的引用，初始化时注册到中介者处，互相引用

需要时通过中介者对象调用另一个工作者类



## 命令模式

将一个请求封装为一个对象从而可以使我们用不同的请求对课后参数化

 

抽象命令类

具体命令类：命令的真正执行者，在命令执行前后可以实现相关的处理 

调用者：命令，可以通过容器实现批处理命令

接受者：完成命令

客户类



## 解释器模式

不常用，用于开发新语言



## 访问者模式

处理集合中不同的对象

容器中的迭代器



## 策略模式

不同用户的不同需求

用于解决某个问题的一个算法族，允许用户从该算法中任选一个来解决问题



定义算法问题接口

定义各种情况的处理类并继承算法问题接口

定义上下文类，负责与具体的算法交互



## 模板方法模式

在某个算法实现时基本步骤固定但某些步骤易变，帮助定义算法骨架，但某些步骤延迟到子类中实现



定义抽象类，把要变动的方法抽象，规定好某些方法的执行和顺序

定义具体的类继承抽象类，重写抽象方法



本质是java的多态



## 状态模式

不同的状态对应不同的行为

 

红绿灯

 

定义基本的状态接口

定义会出现的各种状态并实现各个状态的处理

定义上下文类，实现对各个状态的变动管理



## 观察者模式

广播机制，聊天室，监听器

 

自定义观察者模式：

保持状态标记的一致

定义观察者接口：定义更新操作

定义具体的观察者：状态标记，实现具体的更新操作

定义主题对象类：所有的观察者集合，通知方法

定义某个广播员类继承主题对象类：状态标记和状态变动方法

 

java自带的：

Observable

Observer

 

广播员：调用Observable接口

setChanged（）表示目标对象已经更改

notifyObservers（）通知所有的观察者

观察者：调用Observer接口：重写update方法



## 备忘录模式

word自动恢复，消息撤回，悔棋，回滚操作

拷贝某个对象的内部状态，这样在以后可以恢复到拷贝的状态

 

源发器类：备忘操作，恢复操作

备忘录类：与源发器类属性保持一致

负责人类：备忘录对象，负责保存备忘录对象，可以通过容器实现保存多个备忘

 

备忘录压栈，序列化和持久化

